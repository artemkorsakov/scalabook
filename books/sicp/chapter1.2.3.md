# Глава 1. Построение абстракций с помощью процедур

## 1.2. Процедуры и порождаемые ими процессы

### 1.2.3. Порядки роста

#### Упражнение 1.14

> Нарисуйте дерево, иллюстрирующее процесс, 
> который порождается процедурой `count-change` из раздела 1.2.2 при размене `11` центов. 
> 
> Каковы порядки роста памяти и числа шагов, 
> используемых этим процессом при увеличении суммы, которую требуется разменять?

Поддерево `cc 6 1`:

- `cc 6 1`
  - `cc 6 0`
    - `0` 
  - `cc 5 1`
    - `cc 5 0`
      - `0`
    - `cc 4 1`
      - `cc 4 0`
        - `0` 
      - `cc 3 1`
        - `cc 3 0`
          - `0`
        - `cc 2 1`
          - `cc 2 0`
            - `0`
          - `cc 1 1` 
            - `cc 1 0`
              - `0` 
            - `cc 0 1` 
              - `1`


Дерево `count-change 11`:

- `cc 11 5`
  - `cc 11 4`
    - `cc 11 3`
      - `cc 11 2`
        - `cc 11 1`
          - `cc 11 0`
            - `0` 
          - `cc 10 1`
            - `cc 10 0`
              - `0` 
            - `cc 9 1`
              - `cc 9 0`
                - `0` 
              - `cc 8 1`
                - `cc 8 0`
                  - `0` 
                - `cc 7 1`
                  - `cc 7 0`
                    - `0`  
                  - Поддерево `cc 6 1`
        - `cc 6 2`
          - Поддерево `cc 6 1`
          - `cc 1 2` 
            - `cc 1 1`
              - `cc 1 0`
                - `0` 
              - `cc 0 1` 
                - `1`
            - `cc -4 2`
              - `0` 
      - `cc 1 3` 
        - `cc 1 2`
          - `cc 1 1`
            - `cc 1 0`
              - `0` 
            - `cc 0 1` 
              - `1`
          - `cc -4 2`
            - `0` 
        - `cc -9 3`
          - `0`
    - `cc -14 4`
      - `0`
  - `cc -39 5`
    - `0`

#### Упражнение 1.15

> Синус угла (заданного в радианах) можно вычислить, если воспользоваться приближением **sin x ≈ x** при малых **x** 
> и употребить тригонометрическое тождество **sin(x) = 3sin(x/3) − 4sin<sup>3</sup>(x/3)**
> для уменьшения значения аргумента **sin**. 
> (В этом упражнении будем считать, что угол «достаточно мал», если он не больше 0.1 радиана.)
>
> Эта идея используется в следующих процедурах:
>
> ```
> (define (cube x) (* x x x))
> 
> (define (p x) (- (* 3 x) (* 4 (cube x))))
> 
> (define (sine angle)
>    (if (not (> (abs angle) 0.1))
>        angle
>        (p (sine (/ angle 3.0)))))
> ```
> 
> а. Сколько раз вызывается процедура **p** при вычислении **(sine 12.15)**?
> 
> б. Каковы порядки роста в терминах количества шагов и используемой памяти (как функция **a**) для процесса, 
> порождаемого процедурой **sine** при вычислении **(sine a)**?

На Scala эта программа будет выглядеть так:

```scala
def cube(x: Double): Double = x * x * x

def p(x: Double): Double =
  3 * x - 4 * cube(x)

def sine(angle: Double): Double =
  if math.abs(angle) <= 0.1 then angle
  else p(sine(angle / 3.0))

sine(12.15)
```

а) Процедура `p` будет вызываться `roundUp(12.15 / 3) = 5` раз.

б) Количество шагов будет равняться `2 * roundUp(a / 3)`, столько же будет использование памяти.

[Scala worksheet](https://gitflic.ru/project/artemkorsakov/scalabook/blob?file=examples%2Fsrc%2Fmain%2Fscala%2Fbooks%2Fsicp%2FExercise1-15.worksheet.sc)

---

**Ссылки:**
- [Упражнение 1.14 - 1.15](https://web.mit.edu/6.001/6.037/sicp.pdf#page=84)
