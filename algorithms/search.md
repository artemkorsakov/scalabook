# Поиск

Поиск часто используется в повседневной жизни, а также в компьютерных науках. 
Если мы выполняем ручной поиск, то, скорее всего, пытаемся сопоставить изображение или описание, 
которое есть в нашем мозгу, с искомым реальным объектом. 
Таким образом, это своего рода операция сопоставления с образцом. 
Точно так же сопоставление с образцом является распространенным методом, используемым в вычислениях. 

В текстовом сопоставлении поиск подстроки - очень распространенное требование. 
Если мы выполняем поиск подстроки вручную, то сопоставляем первый символ искомой подстроки с первым символом текста, 
в котором выполняем сопоставление. 
Если совпадает, то продолжаем со вторым символом и так далее. 
Поскольку мы можем перемещать взгляд, то мы могли бы начать с сопоставления с середины страницы 
или с любого места, которое нам нравится. 
Но если мы ищем первое вхождение, то это будет последовательное совпадение или поиск. 
В случае компьютеров сопоставление обычно выполняется последовательно. 
Но это можно изменить, если есть другие требования. 

Поиск может осуществляться широким спектром алгоритмов. 
Ниже рассмотрим несколько алгоритмов: алгоритм наивного поиска и алгоритм поиска Кнута-Морриса-Пратта.

### Алгоритм наивного поиска

- Для первого символа в тексте выполните следующий цикл сопоставления.
  - Сопоставьте первый символ искомой подстроки с текущим символом текста
  - Если есть совпадение, то сопоставьте второй символ подстроки со следующим символом текста.
    Продолжайте до тех пор, пока все символы подстроки не совпадут с символами текста. 
    Если есть полное совпадение, верните индекс текущего символа текста, который в данном случае равен `0`. 
  - Если совпадения нет, выйдите из этого цикла сопоставления.
- Теперь переместите указатель на второй символ текста и продолжите выполнение цикла сопоставления, описанного выше. 
   Любое частичное совпадение теряется в процессе поиска с возвратом. 
   Если есть полное совпадение, вернуть индекс, который в данном случае равен `1`. 
   Если полного совпадения нет, переместите указатель на третий символ. 
- Продолжаем описанные выше шаги, пока не достигнем индекса, который при добавлении к длине подстроки дает длину текста, 
   т.е. за последней начальной точкой сравнения должно следовать достаточное количество символов, 
   чтобы индекс оставался в пределах ограничения. 
   В худшем случае сложность времени выполнения наивного поиска составляет _O(mn)_, 
   где _m_ — длина искомой подстроки, а _n_ — длина текста, в котором выполняется поиск.

Возможная реализация алгоритма:

```scala
def naiveSubstringSearch(searchWord: String, source: String): Int =
  (0 to source.length - searchWord.length)
    .find { i => searchWord.indices.forall(j => source(j + i) == searchWord(j)) }
    .getOrElse(-1)
```


### Алгоритм поиска Кнута-Морриса-Пратта

- Инициализировать переменные. 
  - `m` = длина шаблона (искомая подстрока) 
  - `n` = длина текста 
  - `T` = таблица префиксов 
  - `i` = количество совпадающих символов 
- Сначала вычислите таблицу префиксов. Это препроцесс, который обрабатывает шаблон, чтобы найти совпадения префиксов шаблона с самим шаблоном. 
  Образец здесь представляет собой подстроку для поиска. 
  Он указывает, какая часть последнего сравнения может быть повторно использована, если сравнение не удалось; 
  это улучшение по сравнению с алгоритмом наивного поиска. 
  `P` и `S` обозначают шаблон для поиска и текст, в котором выполняется поиск, соответственно. 
  Функция префикса определяется как размер наибольшего префикса `P[0,1,...,l−1]`, который также является суффиксом `P[1,2,...,l]`. 
  Таблица префиксов вычисляется с помощью следующей подпрограммы, которая имеет сложность времени выполнения _O(m)_.
  ```text
  a. m ← length[P]
  b. T[1] ← 0
  c. k ← 0
  d. for l ← 2 to m do
       while k > 0 and P[k + 1] != p[l] do
         k ← T[k]
       end while
       if P[k + 1] = P[l] then
         k ← k + 1
       end if
       T[l] ← k
     end for
  e. return T
  ```
- Выполните инициализацию переменной: `i = 0` указывает на начало совпадения. 
- Сравнить первый символ искомой подстроки (образца) с первым символом текста. 
  Если это не совпадение, замените значение `T[i]` на `i`. Если это совпадение, увеличьте значение `i` на `1`. 
- Затем проверьте, все ли элементы шаблона совпадают с текстовыми элементами. 
  Если не совпадают, повторите процесс поиска. Если совпало, верните начальный индекс совпадающей подстроки текста. 
- Продолжайте описанные выше шаги, чтобы найти следующее совпадение. 
- Вышеуказанные шаги могут быть представлены следующим псевдокодом:
  ```text
  a. n ← length[S]
  b. m ← length[P]
  c. T ← computePrefixTable(P), вызвать подпрограмму вычисления префикса выше.
  d. i ← 0
  e. for j ← 1 to n do
       while i > 0 and P[i + 1] != S[j] do
         i ← T[i]
         if P[i + 1] = S[j] then
           i ← i + 1
         end if
         if i = m then
           i ← P[i]
         end if
       end while
     end for
  ```
- Возвращает набор начальных индексов для всех совпадающих подстрок текста. 
  Сложность времени выполнения вычисления таблицы префиксов составляет _O(m)_. 
  Для сравнения шаблона с текстом требуется _O(n)_. 
  Следовательно, общая сложность времени выполнения составляет _O(m+n)_.

Чтобы пояснить приведенный выше алгоритм, давайте вычислим таблицу префиксов для `P = {xyxyxzx}`. 
Первоначально `m = length[P] = 7`, `T[1] = 0` и `k = 0`. 
Как показано в приведенном выше алгоритме, `m` — это длина искомого шаблона или строки, 
`T` — таблица префиксов и `k` — начальное значение потенциала, которое инициализируется `0`.

- Step 1: `l = 2`, `k = 0`, `T[2] = 0`

  | l | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
  |---|---|---|---|---|---|---|---|
  | P | x | y | x | y | x | z | x |
  | T | 0 | 0 |   |   |   |   |   |
  



[Исходный код](https://gitflic.ru/project/artemkorsakov/scalabook/blob?file=examples%2Fsrc%2Fmain%2Fscala%2Falgorithms%2Fsearch%2FSearch.scala&plain=1)

[Тесты](https://gitflic.ru/project/artemkorsakov/scalabook/blob?file=examples%2Fsrc%2Ftest%2Fscala%2Falgorithms%2Fsearch%2FSearchSuite.scala&plain=1)


---

**References:**
- [Bhim P. Upadhyaya - Data Structures and Algorithms with Scala](https://link.springer.com/book/10.1007/978-3-030-12561-5)
