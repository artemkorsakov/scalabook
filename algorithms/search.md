# Поиск

Поиск часто используется в повседневной жизни, а также в компьютерных науках. 
Если мы выполняем ручной поиск, то, скорее всего, пытаемся сопоставить изображение или описание, 
которое есть в нашем мозгу, с искомым реальным объектом. 
Таким образом, это своего рода операция сопоставления с образцом. 
Точно так же сопоставление с образцом является распространенным методом, используемым в вычислениях. 

В текстовом сопоставлении поиск подстроки - очень распространенное требование. 
Если мы выполняем поиск подстроки вручную, то сопоставляем первый символ искомой подстроки с первым символом текста, 
в котором выполняем сопоставление. 
Если совпадает, то продолжаем со вторым символом и так далее. 
Поскольку мы можем перемещать взгляд, то мы могли бы начать с сопоставления с середины страницы 
или с любого места, которое нам нравится. 
Но если мы ищем первое вхождение, то это будет последовательное совпадение или поиск. 
В случае компьютеров сопоставление обычно выполняется последовательно. 
Но это можно изменить, если есть другие требования. 

Поиск может осуществляться широким спектром алгоритмов. 
Ниже рассмотрим несколько алгоритмов: алгоритм наивного поиска и алгоритм поиска Кнута-Морриса-Пратта.

### Алгоритм наивного поиска

- Для первого символа в тексте выполните следующий цикл сопоставления.
  - Сопоставьте первый символ искомой подстроки с текущим символом текста
  - Если есть совпадение, то сопоставьте второй символ подстроки со следующим символом текста.
    Продолжайте до тех пор, пока все символы подстроки не совпадут с символами текста. 
    Если есть полное совпадение, верните индекс текущего символа текста, который в данном случае равен `0`. 
  - Если совпадения нет, выйдите из этого цикла сопоставления.
- Теперь переместите указатель на второй символ текста и продолжите выполнение цикла сопоставления, описанного выше. 
   Любое частичное совпадение теряется в процессе поиска с возвратом. 
   Если есть полное совпадение, вернуть индекс, который в данном случае равен `1`. 
   Если полного совпадения нет, переместите указатель на третий символ. 
- Продолжаем описанные выше шаги, пока не достигнем индекса, который при добавлении к длине подстроки дает длину текста, 
   т.е. за последней начальной точкой сравнения должно следовать достаточное количество символов, 
   чтобы индекс оставался в пределах ограничения. 
   В худшем случае сложность времени выполнения наивного поиска составляет _O(mn)_, 
   где _m_ — длина искомой подстроки, а _n_ — длина текста, в котором выполняется поиск.

Возможная реализация алгоритма:

```scala
def naiveSubstringSearch(searchWord: String, source: String): Int =
  (0 to source.length - searchWord.length)
    .find { i => searchWord.indices.forall(j => source(j + i) == searchWord(j)) }
    .getOrElse(-1)
```


### Алгоритм поиска Кнута-Морриса-Пратта



[Исходный код](https://gitflic.ru/project/artemkorsakov/scalabook/blob?file=examples%2Fsrc%2Fmain%2Fscala%2Falgorithms%2Fsearch%2FSearch.scala&plain=1)

[Тесты](https://gitflic.ru/project/artemkorsakov/scalabook/blob?file=examples%2Fsrc%2Ftest%2Fscala%2Falgorithms%2Fsearch%2FSearchSuite.scala&plain=1)


---

**References:**
- [Bhim P. Upadhyaya - Data Structures and Algorithms with Scala](https://link.springer.com/book/10.1007/978-3-030-12561-5)
