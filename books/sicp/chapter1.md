# Глава 1. Построение абстракций с помощью процедур

## 1.1 Элементы программирования

### 1.1.1 Выражения - 1.1.6 Условные выражения и предикаты

#### Упражнение 1.1

```scala
10                    // 10
(5 + 3 + 4)           // 12
(9 - 1)               // 8
(6 / 2)               // 3
((2 * 4) + (4 - 6))   // 6
val a = 3
val b = a + 1         // 4
(a + b + (a * b))     // 19
(a == b)              // false

if (b > a) && (b < (a * b)) then b else a                  // 4

if a == 4 then 6
else if b == 4 then 6 + 7 + a
else 25                                                    // 16
 
2 + (if (b > a) then b else a)                             // 6

((if a > b then a else if a < b then b else -1) * (a + 1)) // 16
```

[Scala worksheet](https://gitflic.ru/project/artemkorsakov/scalabook/blob?file=examples%2Fsrc%2Fmain%2Fscala%2Fbooks%2Fsicp%2FExercise1-1.worksheet.sc)

#### Упражнение 1.2

Выражение 

```text
(5 + 4 + (2 - (3 - (6 + 5 / 4)))) / (3(6 - 2)(2 - 7))
```

в префиксной форме выглядит так:

```text
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 7 2)))
```

#### Упражнение 1.3 

> Определите процедуру, которая принимает в качестве аргументов три числа и возвращает сумму
> квадратов двух больших из них.

```scala
def square(x: Int): Int = x * x

def sumOfSquares(x: Int, y: Int): Int = square(x) + square(y)

def f(a: Int, b: Int, c: Int): Int =
  if a <= b && a <= c then sumOfSquares(b, c)
  else if b <= c then sumOfSquares(a, c)
  else sumOfSquares(a, b)

f(5, 3, 4)  // 41
```

[Scala worksheet](https://gitflic.ru/project/artemkorsakov/scalabook/blob?file=examples%2Fsrc%2Fmain%2Fscala%2Fbooks%2Fsicp%2FExercise1-3.worksheet.sc)

#### Упражнение 1.4

Процедура `a-plus-abs-b`:

```text
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

работает так:

- если `b` больше `0`, то выполняется процедура `(+ a b)`
- в ином случае, выполняется процедура `(- a b)`

Эта процедура складывает `a` и модуль числа `b`.

#### Упражнение 1.5

> Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком вычислений он
> работает, аппликативным или нормальным. Бен определяет такие две процедуры:
> 
> ```
> (define (p) (p))
> ```
> 
> ```
> (define (test x y)
>   (if (= x 0)
>     0
>     y))
> ```
> 
> Затем он вычисляет выражение
> 
> ```
> (test 0 (p))
> ```
> 
> Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок вычислений?
> Какое поведение он увидит, если интерпретатор использует нормальный порядок?

При аппликативном порядке исчисления результат `(test 0 (p))` не будет получен, потому что невозможно вычислить второй аргумент.
При нормально порядке исчисления результат `(test 0 (p))` будет равен `0`, потому что аргументы не вычисляются
и `(test 0 (p))` разложиться до:

```
if (= 0 0)
  0
  y
```

, что в свою очередь вернет `0`.

### 1.1.7 Пример: вычисление квадратного корня методом Ньютона

#### Упражнение 1.6


---

**Ссылки:**
- [Упражнение 1.1 - 1.5](https://web.mit.edu/6.001/6.037/sicp.pdf#page=54)
