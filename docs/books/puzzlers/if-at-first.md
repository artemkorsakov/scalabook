# If At First You Don't Succeed...

```scala
var x = 0
lazy val y = 1 / x

try println(y)
catch
  case _: Throwable =>
    x = 1
    println(y)
// 1    
```

Одна из самых интересных особенностей ленивых значений (кроме того, что они откладывают фактическое вычисление) 
заключается в том, что они будут пересчитываться при вызове, 
если в момент первого доступа возникло исключение, 
до тех пор, пока не будет получено какое-то определенное значение. 
Таким образом, можно использовать этот полезный шаблон во многих ситуациях, 
например, для обработки отсутствующих файлов.


---

**Ссылки:**
- [Scala Puzzlers](https://scalapuzzlers.com/index.html#pzzlr-012)
