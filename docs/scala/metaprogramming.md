# Метапрограммирование

На следующих страницах представлен дизайн метапрограммирования в Scala. 
Он вводит следующие основные средства:

- [inline](https://scalabook.gitflic.space/docs/scala/metaprogramming/inline) функция позволяет помечать некоторые абстракции (значения и методы) 
как статически сводимые. Она обеспечивает точку входа для макросов и других утилит метапрограммирования.
- [Операции времени компиляции](https://scalabook.gitflic.space/docs/scala/metaprogramming/compile-time-ops) 
предлагают дополнительные утилиты метапрограммирования, которые можно использовать в `inline` методах 
(например, для улучшения отчетов об ошибках) без необходимости определять макрос.
- [Макросы](https://scalabook.gitflic.space/docs/scala/metaprogramming/macros) построены на двух фундаментальных операциях: 
цитатах и склейках. 
Цитата преобразует программный код в данные, а именно в (древовидное) представление этого кода. 
Это выражается как `'{...}` для выражений, так и `'[...]` для типов. 
Склеивание, выраженное как `${ ... }`, идет другим путем: оно преобразует представление программы в программный код. 
Вместе с `inline`, эти две абстракции позволяют программно конструировать код. 
- [Постановка во время выполнения](https://scalabook.gitflic.space/docs/scala/metaprogramming/runtime-staging). 
В то время как макросы создают код во время компиляции, 
постановка позволяет программам создавать новый код во время выполнения. 
Таким образом, генерация кода может зависеть не только от статических данных, 
но и от данных, доступных во время выполнения. 
Это разделяет оценку программы на две или более стадий. 
Следовательно, этот метод генеративного программирования называется "Многоэтапное программирование". 
Постановка построена на тех же принципах, что и макросы. Он использует цитаты и склейки, но не включает `inline`. 
- [Рефлексия](https://scalabook.gitflic.space/docs/scala/metaprogramming/reflection) Цитаты — это представление кода в виде "черного ящика". 
Они могут быть параметризованы и составлены с помощью склеивания, но их структура не может быть проанализирована извне. 
Отражение TASTy позволяет анализировать структуру кода, 
частично раскрывая тип представления фрагмента кода в стандартном API. 
Тип представления — это форма типизированного абстрактного синтаксического дерева, которое порождает `TASTy` моникер. 
- [TASTy Inspection](https://scalabook.gitflic.space/docs/scala/metaprogramming/tasty-inspection) 
Типизированные абстрактные синтаксические деревья сериализуются в специальном сжатом двоичном формате, 
хранящемся в `.tasty` файлах. 
Проверка TASTy позволяет загружать эти файлы и анализировать древовидную структуру их содержимого.


---

**Ссылки:**

- [Scala 3 Guide](https://docs.scala-lang.org/scala3/guides/macros/)
- [Scala 3 Reference](https://docs.scala-lang.org/scala3/reference/metaprogramming.html)
