# Return to Me!

```scala
def value: Int = 
  def one(x: Int): Int = { return x; 1 }
  val two = (x: Int) => { return x; 2 }
  1 + one(2) + two(3)

println(value)
// 3
```

Scala не жалуется на _unreachable code_, поэтому код компилируется нормально. 
Если необходимо получать предупреждения о недостижимом коде, используйте параметр компилятора `-Ywarn-dead-code`. 
Если необходимо видеть ошибку компилятора вместо предупреждения, 
то дополнительно используйте опцию компилятора `-Xfatal-warnings`. 
Ответ на этот вопрос можно найти в SLS §6.20: 

> Выражение возврата return e должно встречаться внутри тела некоторого включающего его именованного метода или функции. 
> Самый внутренний объемлющий именованный метод или функция в исходной программе, f, 
> должен иметь явно объявленный тип результата, и тип e должен ему соответствовать. 
> Выражение возврата оценивает выражение e и возвращает его значение как результат f. 
> Оценка любых операторов или выражений, следующих за возвращаемым выражением, опускается. 

Для первого оператора `return x` объемлющий именованный метод является методом номер один, 
но для второго оператора `return x` объемлющий именованный метод является значением метода. 
Когда функция `two(3)` вызывается как часть выражения `1 + one(2) + two(3)`, 
то результат `3` возвращается как результат значения метода. 
Кстати, возврат из вложенной анонимной функции реализуется путем создания 
и перехвата `scala.runtime.NonLocalReturnControl`. 
Наиболее распространенная причина, по которой вы действительно хотели бы вернуться из вложенной функции, — 
это выход из императивного блока _for-comprehension_ или блока управления ресурсами. 
См. ответы на вопрос о переполнении стека
[Цель оператора return в Scala?](https://stackoverflow.com/questions/3770989/purpose-of-return-statement-in-scala/3771243#3771243) 
для дальнейшего обсуждения этого аспекта.


---

**Ссылки:**
- [Scala Puzzlers](https://scalapuzzlers.com/index.html#pzzlr-018)
