# Oddly Enough

```scala
var mkEven: Int => Int = _
def initMkEven(): Unit = 
  mkEven = (n: Int) => if n % 2 == 0 then n else return n + 1
initMkEven()

println(mkEven(2))
// 2
println(mkEven(3))
// scala.runtime.NonLocalReturnControl
```

Согласно SLS (§6.20), выражение `return` должно находиться 
«внутри тела некоторого включающего именованного метода или функции»
и заставляет самый внутренний такой метод или функцию возвращать заданное значение. 
Если выражение `return` встречается внутри анонимной функции, как в этом случае, 
компилятор Scala не может преобразовать его в простую инструкцию возврата JVM. 
Тело анонимной функции становится телом метода `apply`, сгенерированного компилятором, 
и инструкция возврата JVM просто завершает этот метод применения. 
Он не будет переходить к самому внутреннему вмещающему именованному методу или функции в программе, как планировалось. 
Поэтому `return` из вложенной анонимной функции 
вместо этого реализуется путем выбрасывания `scala.runtime.NonLocalReturnControl` в точке возвращаемого выражения 
и перехвата его вокруг включающего метода или функции. 
В этом случае рассматриваемый именованный метод называется `initMkEven`, 
и компилятор вставляет вокруг него соответствующее предложение `catch`. 
Однако оператор `return`, который фактически становится `throw new NonLocalReturnControl`, 
выполняется после того, как мы вернулись из `initMkEven`. 
Без «страховочной сетки», которая могла бы его поймать и обработать, 
исключение во время выполнения возникает, когда мы вызываем `mkEven(3)`.


---

**Ссылки:**
- [Scala Puzzlers](https://scalapuzzlers.com/index.html#pzzlr-049)
