# Копирование файлов — основные понятия, обработка ресурсов и отмена

Наша цель — создать программу, которая копирует файлы. 
Сначала мы поработаем над функцией, выполняющей такую задачу, а затем создадим программу, 
которую можно будет вызывать из оболочки и использовать эту функцию.

Прежде всего, мы должны написать функцию, которая копирует содержимое из файла в другой файл. 
Функция принимает исходный и конечный файлы в качестве параметров. 
Но это функциональное программирование! 
Таким образом, вызов функции ничего не копирует, вместо этого он возвращает `IO` экземпляр, 
который инкапсулирует все задействованные побочные эффекты (открытие/закрытие файлов, чтение/запись содержимого), 
таким образом сохраняется чистота и отсутствие side effects. 
Только когда этот `IO` экземпляр будет выполнен, будут запущены все эти действия с побочными эффектами. 
В нашей реализации `IO` экземпляр будет возвращать количество байтов, скопированных при выполнении, 
но это всего лишь дизайнерское решение. 
Конечно могут возникать ошибки, но при работе с любыми `IO` их следует закладывать в `IO` пример. 
То есть никакое исключение не возникает за пределами `IO` 
и поэтому при использовании функции не нужно использовать `try` (или подобное), 
вместо этого выполнение `IO` завершится ошибкой и `IO` экземпляр будет её содержать.

Сигнатура функции выглядит так:

```scala
import cats.effect.IO
import java.io.File

def copy(origin: File, destination: File): IO[Long] = ???
```



## Исходный код

[Исходный код](https://gitflic.ru/project/artemkorsakov/scalabook/blob?file=examples%2Fsrc%2Fmain%2Fscala%2Flibs%2Fhttp4s%2FPingApp.scala&plain=1)

---

**References:**
- [Cats effect documentation](https://typelevel.org/cats-effect/docs/tutorial#a-namecopyingfilesacopying-files---basic-concepts-resource-handling-and-cancelation)
