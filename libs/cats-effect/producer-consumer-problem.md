# Проблема производитель-потребитель — параллелизм и волокна

Модель производитель-потребитель часто встречается в параллельных запусках. 
Здесь один или несколько производителей вставляют данные в общую структуру данных, такую как очередь, 
в то время как один или несколько потребителей извлекают данные из нее. 
Читатели и писатели работают одновременно. 
Если очередь пуста, то читатели будут блокироваться до тех пор, пока данные не будут доступны, 
если очередь заполнена, то писатели будут ждать освобождения некоторого «сегмента». 
Только один модуль записи может одновременно добавлять данные в очередь, чтобы предотвратить повреждение данных. 
Кроме того, только один считыватель может извлекать данные из очереди, 
поэтому никакие два считывателя не могут получить один и тот же элемент данных.

Существуют вариации этой проблемы в зависимости от того, имеется ли более одного потребителя/производителя, 
или структура данных, находящаяся между ними, ограничена по размеру или нет. 
Решения, обсуждаемые здесь, подходят для настроек с несколькими потребителями и несколькими читателями. 
Сначала мы будем предполагать неограниченную структуру данных, а позже предложим решение для ограниченной.

Но прежде чем мы приступим к решению этой проблемы, мы должны определить волокна (файбэс - fibers), 
которые являются основным строительным блоком параллелизма на основе cats-effect.

## Введение в волокна

Волокно содержит `F` действие для выполнения (обычно `IO` экземпляр). 
Волокна похожи на «легкие» потоки, то есть их можно использовать так же, как и потоки, для создания параллельного кода. 
Однако они не являются потоками. 
Порождение новых волокон не гарантирует, что действие, описанное в `F` связанном с ним, 
будет выполнено в случае нехватки потоков. 
Внутренне cats-effect использует пулы потоков для запуска волокон при работе на JVM. 
Таким образом, если в пуле нет доступного потока, выполнение волокна будет «ждать», 
пока какой-либо поток снова не освободится. 
С другой стороны, когда выполнение некоторого волокна заблокировано, 
например поскольку он должен ждать освобождения семафора, поток, выполняющий волокно, 
повторно используется с помощью кошачьего эффекта, поэтому он доступен для других волокон. 
Когда выполнение волокна может быть возобновлено, cats-effect будет искать свободный поток для продолжения выполнения. 
Термин «семантически заблокированный» иногда используется для обозначения того, 
что блокирование волокна не влечет за собой остановку какого-либо потока. 
Cats-effect также перерабатывает волокна из готовых и погашенных волокон. 
Но имейте в виду, что, напротив, если волокно действительно заблокировано каким-то внешним действием, 
например, ожиданием некоторого ввода из TCP-сокета, 
то у Cats-effect нет возможности восстановить этот поток, пока действие не завершится. 
Такие вызовы должны быть обернуты `IO.blocking`, чтобы сигнализировать о том, что обернутый код заблокирует поток. 
Cats-effect использует эту информацию как подсказку для оптимизации `IO` планирования.

Еще одно отличие потоков заключается в том, что волокна — очень дешевые объекты. 
Мы можем легко создать миллионы из них, не влияя на производительность.

Стоит отметить, что вам не нужно явно отключать волокна. 
Если вы создадите волокно и оно закончит активную работу `IO`, то оно будет очищено сборщиком мусора, 
если только на него не будет какой-либо другой активной ссылки в памяти.
Таким образом, вы можете рассматривать волокно как любой другой обычный объект, 
за исключением того, что, когда волокно работает, сама среда выполнения с cats-effect поддерживает волокно в живых.

Это также имеет некоторые интересные последствия. 
Например, если вы создаете узел `IO.async` и регистрируете обратный вызов с чем-то, 
и находитесь в волокне, у которого нет сильных ссылок на объекты где-либо еще 
(т.е. вы сделали что-то вроде действия «запустил и забыл»), 
тогда сам обратный вызов является единственной сильной ссылкой на волокно. 
Это означает, что если регистрация завершится ошибкой или система, в которой вы зарегистрировались, выбросит ее, 
волокно просто изящно исчезнет.

Cats-effect реализует некоторые примитивы параллелизма для координации параллельных волокон: 
[Deferred](https://typelevel.org/cats-effect/docs/std/deferred), [Ref](https://typelevel.org/cats-effect/docs/std/ref), 
[Semaphore](https://typelevel.org/cats-effect/docs/std/semaphore) ...

Более подробную информацию о параллелизме в cats-effect можно найти 
в этом учебнике [«Параллелизм в Scala с cats-effect»](https://github.com/slouc/concurrency-in-scala-with-ce).

Хорошо, теперь, после краткого рассмотрения волокон, можно начать работать над проблемой производителя-потребителя.

## Первая (и неэффективная) реализация

Нам нужна промежуточная структура, в которую производитель(-и) может вставлять данные, а потребитель(-и) извлекать. 
Предположим, что это простая очередь. Первоначально будет только один производитель и один потребитель. 
Производитель сгенерирует последовательность целых чисел (`1`, `2`, `3`...), 
а потребитель просто прочитает эту последовательность. 
Наша общая очередь будет экземпляром неизменного объекта `Queue[Int]`.

Доступ к очереди может (и будет!) быть одновременным, поэтому нам нужен какой-то способ защитить очередь, 
чтобы только одно волокно одновременно обрабатывало ее. 
Лучший способ обеспечить упорядоченный доступ к некоторым общим данным — [`Ref`](https://typelevel.org/cats-effect/docs/std/ref). 
Экземпляр `Ref` упаковывает некоторые заданные данные и реализует методы для безопасного управления этими данными. 
Когда какое-то волокно запускает один из этих методов, 
любой другой вызов любого метода `Ref` экземпляра будет заблокирован.

Обертка `Ref` для нашей очереди будет `Ref[F, Queue[Int]]` (для некоторых `F[_]`).

Теперь метод `producer` будет таким:

```scala
import cats.effect.*
import cats.effect.std.Console
import cats.syntax.all.*
import collection.immutable.Queue

def producer[F[_]: Sync: Console](queueR: Ref[F, Queue[Int]], counter: Int): F[Unit] =
  for {
    _ <- if counter % 10000 == 0 then Console[F].println(s"Produced $counter items") else Sync[F].unit
    _ <- queueR.getAndUpdate(_.enqueue(counter + 1))
    _ <- producer(queueR, counter + 1)
  } yield ()
```


## Исходный код

[Исходный код](https://gitflic.ru/project/artemkorsakov/scalabook/blob?file=examples%2Fsrc%2Fmain%2Fscala%2Flibs%2Fcats%2Feffect%2FCopyFilesF.scala&plain=1)


---

**References:**
- [Cats effect documentation](https://typelevel.org/cats-effect/docs/tutorial#a-nameproducerconsumeraproducer-consumer-problem---concurrency-and-fibers)
