# Декомпозиция в Scala 3

Посмотрим, в чем главное отличие декомпозиции в Scala 3 по сравнению со Scala 2.

Основным инструментом декомпозиции в Scala 3 ещё больше становятся `trait`-ы.
И для этого есть несколько причин.

### 1. Теперь trait-ы могут иметь параметры конструктора, как и классы

Напомним, что `trait`-ы могут содержать:

- абстрактные методы и поля
- конкретные методы и поля
- могут иметь параметры конструктора, как и классы

Например:

```scala
trait Greeting(val name: String):
  protected val firstPart: String
  def msg = s"$firstPart $name"

trait Hello:
  val firstPart: String = "Hello"

object EnglishGreeting extends Greeting("Bob"), Hello

EnglishGreeting.msg  // Hello Bob
```

При этом при расширении параметризованного `trait`-а действуют следующие правила:

- Если класс `C` расширяет параметризованный `trait` `T`, 
  а его суперкласс — нет, то `C` должен передать аргументы в `T`.
- Если класс `C` расширяет параметризованный `trait` `T` 
  и его суперкласс тоже, то `C` не должен передавать аргументы в `T`.
- `trait`-ы никогда не должны передавать аргументы родительским `trait`-ам.


Вот трейт, расширяющий параметризованный трейт Greeting.

### 2. Расширение нескольких trait-ов

Классы и объекты могут расширять несколько `trait`-ов, в отличие от абстрактных классов,
что делает `trait`-ы более мощным средством декомпозиции.