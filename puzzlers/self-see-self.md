# Self - See 'Self'

```scala
val s1: String = s1
val s2: String = s2 + s2
println(s1.length) // NullPointerException
println(s2.length) // 8
```

Определения значений `s1` и `s2` действительны и компилируются без ошибок. 
Поскольку определения являются рекурсивными, необходимо указать тип объявленных значений (SLS §4.1). 
В Scala поля объекта предварительно инициализируются до значения по умолчанию, 
а для типа `String` (и всех других ссылочных типов) значение по умолчанию равно `null`. 
Это как в Java. 

Однако такое рекурсивное определение поля в теле класса Java дает недопустимую ошибку компилятора прямой ссылки:

```java
class Z {
   String s = s + s;
}
```

, но следующее компилируется нормально:

```java
class Z {
    String s = this.s + this.s;
}
```

Это показывает, что проверка, которую выполняет компилятор Java, довольно поверхностна. 

Способ Scala принимать рекурсивные определения для всех ситуаций более последователен. 
Что остается объяснить, так это результат этой головоломки. 
Значение `s1` инициализируется `null`, 
поэтому выражение `s1.length` заканчивается `NullPointerException` во время выполнения. 
Инициализация значения `s2` фактически преобразуется в байтовый код, 
эквивалентный `s2 = (new StringBuilder()).append(s2).append(s2).toString()`, 
где аргумент `s2` имеет значение по умолчанию `null`. 
Согласно JLS, раздел 15.18.1.1, ссылка `null` преобразуется в строку `"null"`, 
а значение, которое присваивается `s2`, представляет собой строку `"nullnull"` длиной `8`.


---

**References:**
- [Scala Puzzlers](https://scalapuzzlers.com/index.html#pzzlr-016)
