# Декомпозиция в Scala 3, возможные проблемы и их решения

## Наследование, которое не расширяет

Рассмотрим несколько распространенных ошибок, которые возникают при попытке декомпозиции.

Для начала рассмотрим пример моноида:

```scala
trait Monoid[A]:
  def e: A
  extension (x: A) def |+|(y: A): A
```

Моноид обладает двумя свойствами:

- умеет "складывать" два объекта заданного типа (и это сложение ассоциативно)
- обладает единичным элементом, который при "сложении" с любым другим элементом должен возвращать этот второй элемент.

Например, можно определить моноид для связанного списка:

```scala
given listMonoid[T]: Monoid[List[T]] with
  override def e: List[T] = List.empty
  extension (x: List[T]) override def |+|(y: List[T]): List[T] = x ++ y
```

Но что если мы сталкиваемся со структурой, у которой нет единичного элемента, например:

```scala
final case class NonEmptyList[A](head: A, tail: List[A]):
  def ++(that: NonEmptyList[A]): NonEmptyList[A] =
    NonEmptyList(head, tail ++ (that.head :: that.tail))
```

Как в этом случае определить моноид?

```scala
given monoidWithException[T]: Monoid[NonEmptyList[T]] with
  override def e: NonEmptyList[T] = ???
  
  extension (x: NonEmptyList[T])
    override def |+|(y: NonEmptyList[T]): NonEmptyList[T] = x ++ y
```

#### Правильное поведение

Правильным решением в данной ситуации является выделение родительской структуры из моноида 
(эта структура назвается полугруппа)

```scala

```


Есть две наиболее распространенные ошибки при попытке декомпозиции:

1) Выдавать исключение для несуществующего элемента
2) Преобразовать его в `Option[A]`

Рассмотрим оба варианта.

#### Выдача исключения

```scala
given monoidWithException[T]: Monoid[NonEmptyList[T]] with
  override def e: NonEmptyList[T] =
    throw new IllegalArgumentException("...")
    
  extension (x: NonEmptyList[T])
    override def |+|(y: NonEmptyList[T]): NonEmptyList[T] = x ++ y
```

Логика понятна: если у непустого списка нет единичного элемента, 
то мы запрещаем его использовать в каких бы то ни было ситуациях. 
Но по большому счету здесь получился самообман: 
попытка представить, что заданная структура обладает заданным поведением, когда на самом деле это не так.

- либо это делается по привычке: к моноиду все привыкли, а тут появляется какая-то новая структура. 
- либо это делается из-за "экономии" места.

Но оба варианта ошибочны:

- все равно всем придется помнить, что "на `NonEmptyList` нельзя вызывать единичный элемент"
- в дальнейшем коде придется как-то обрабатывать "исключительную ситуацию"

Новая структура создана и она "живет своей жизнью", просто это принудительно "глушится" в коде.


