# Проблемы построения архитектуры на примере Моноидов

Обычно статьи такого рода строятся вначале с разбора ошибок и постепенному переходу к "идеальному" по мнению автора варианту.
Эта статья будет построена с точностью до наоборот: разберем идеальный вариант, а затем перейдем к проблемам.

Рассмотрим развитие построения архитектуры на примере моноидальной группы из теории категорий.

Возьмем для примера [полугруппу](../typeclass/monoid/semigroup) и [моноид](../typeclass/monoid/monoid), 
детально рассмотренные на соответствующих страницах.

Напомню определение полугруппы:

> `(S, +)` является полугруппой (_semigroup_) для множества `S` и операции `+`, 
> если удовлетворяет следующим свойствам для любых `x, y, z ∈ S`:
> - Closure (замыкание): `x + y ∈ S`
> - Associativity (ассоциативность): `(x + y) + z = x + (y + z)`
> 
> Также говорится, что _S образует полугруппу относительно +_.

И определение моноида:

> Моноид (_monoid_) — это полугруппа с единичным элементом.
> 
> Более формально: `(M, +)` является моноидом для заданного множества `M` и операции `+`,
> если удовлетворяет следующим свойствам для любых `x, y, z ∈ M`:
> - Closure (замыкание): `x + y ∈ M`
> - Associativity (ассоциативность): `(x + y) + z = x + (y + z)`
> - Identity (тождественность): существует единичный элемент `e ∈ M` (`empty: A`) такой, что `e + x = x + e = x` 

Давайте посмотрим, как это выглядит в Scala.

В качестве операции `+` из определения полугруппы будем использовать название `|+|`, 
чтобы не путать со стандартным методом `+`(сложение чисел, конкатенация строк).

Тогда определение полугруппы будет выглядеть так:

```scala
trait Semigroup[A]:
  extension (x: A)
    def |+|(y: A): A
```

Как видно, тут автоматически выполняется закон "Замыкания" исходя из определения метода - результирующий тип тот же самый, что и тип параметров.

Проверку ассоциативности надо же добавлять - сделаем это в сопутствующем объекте:

```scala
object Semigroup:
  def doTheSemigroupLawsHold[A: Semigroup](x: A, y: A, z: A): Boolean =
    val s = summon[Semigroup[A]]
    import s.|+|
    ((x |+| y) |+| z) == (x |+| (y |+| z))
```

Теперь мы всегда можем проверить, является ли заданное множество полугруппой относительно заданной операции на произвольной выборке.

Например, интуитивно понятно, что множество целых чисел относительно умножения образуют полугруппу:
- Closure: результат умножения - целое число
- Associativity: порядок умножения чисел не имеет значения

Проверим это с помощью scalacheck на произвольной выборке:

```scala
property("Множество чисел образует полугруппу относительно умножения") {
  given Semigroup[Int] with
    extension (x: Int) override def |+|(y: Int): Int = x * y

  forAll(smallNumber, smallNumber, smallNumber) { (x: Int, y: Int, z: Int) =>
    assert(doTheSemigroupLawsHold(x, y, z))
  }
}
```

На произвольной выборке тест проходит успешно.

> Замечание о переполнении: чтобы не думать о переполнении при умножении трех `Int`, 
> выборка осуществлялась на произвольных числах от `-100` до `100`. 



