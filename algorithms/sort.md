# Сортировка

Сортировка — обычная операция как в жизни, так и в информатике.
В нашей повседневной жизни мы сортируем элементы, чтобы поиск был быстрее, это верно и в области компьютерных наук.
В конце концов, компьютеры существуют, чтобы помогать нам в повседневных задачах.
Сортировка может присутствовать на разных уровнях в зависимости от требований. 
Например, иногда нам может понадобиться отсортировать символ за символом. 
В других случаях нам может понадобиться отсортировать более крупные структуры, например профили компаний. 
Какой бы ни была причина, основной принцип сортировки остается прежним. 

Кроме того, существует два порядка сортировки — по возрастанию и по убыванию. 
Предположим, что нужно отсортировать _n_ элементов: _<a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,...,a<sub>n</sub>>_. 
Когда эти элементы отсортированы в порядке возрастания, 
их отношение можно формально сформулировать как a<sub>1</sub> ≤ a<sub>2</sub> ≤ a<sub>3</sub> ≤ ... ≤ a<sub>n</sub>. 
Точно так же их сортировка по убыванию может быть формально сформулирована 
как a<sub>n</sub> ≥ a<sub>n−1</sub> ≥ a<sub>n−2</sub> ≥ a<sub>2</sub> ≥ a<sub>1</sub>.


### Сортировка пузырьком (Bubble Sort)

Алгоритм [сортировки пузырьком](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D1%83%D0%B7%D1%8B%D1%80%D1%8C%D0%BA%D0%BE%D0%BC) 
состоит из повторяющихся проходов по сортируемому массиву. 
За каждый проход элементы последовательно сравниваются попарно 
и, если порядок в паре неверный, выполняется перестановка элементов. 
Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, 
что обмены больше не нужны, что означает — массив отсортирован. 
При каждом проходе алгоритма по внутреннему циклу очередной наибольший элемент массива ставится 
на своё место в конце массива рядом с предыдущим «наибольшим элементом», 
а наименьший элемент перемещается на одну позицию к началу массива 
(«всплывает» до нужной позиции, как пузырёк в воде — отсюда и название алгоритма).

Возможная реализация алгоритма такая:

```scala
def bubbleSort[T: Ordering](array: Array[T]): Unit =
  val ord = summon[Ordering[T]]
  def loop(j: Int): Boolean =
    (0 to array.length - 1 - j)
      .withFilter(i => ord.gt(array(i), array(i + 1)))
      .map(i => swap(array, i, i + 1))
      .nonEmpty
  (1 until array.length).takeWhile(loop)
  ()
```

### Сортировка выбором

Шаги [алгоритма сортировки выбором](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%BE%D0%BC):
- находим номер минимального значения в текущем списке
- производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции)
- теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы

Возможная реализация алгоритма такая:

```scala
def selectionSort[T: Ordering](array: Array[T]): Unit =
  (0 until array.length - 1).foreach { i =>
    val j = (i until array.length).minBy(j => array(j))
    swap(array, i, j)
  }
```




[Исходный код](https://gitflic.ru/project/artemkorsakov/scalabook/blob?file=examples%2Fsrc%2Fmain%2Fscala%2Falgorithms%2Fsort%2FSorting.scala&plain=1)

[Тесты](https://gitflic.ru/project/artemkorsakov/scalabook/blob?file=examples%2Fsrc%2Ftest%2Fscala%2Falgorithms%2Fsort%2FSortingSuite.scala)

---

**References:**
- [Bhim P. Upadhyaya - Data Structures and Algorithms with Scala](https://link.springer.com/book/10.1007/978-3-030-12561-5)
